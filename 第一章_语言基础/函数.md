# 函数

函数有具名和匿名之分：具名函数一般对应于包级的函数，是匿名函数的一种特例。当匿名函数引用了外部作用域中的变量时就成了闭包函数，闭包函数是函数式编程语言的核心。

Go语言中，函数可以保存到变量中。

每个类型可以有自己的方法，方法也是函数的一种。

- 具名函数

    ```go
    func Add(a, b int) int {
	return a + b
    }
    ```

- 匿名函数

    ```go
    var AddV2 = func(a, b int) int {
        return a + b
    }
    ```

- 多个参数和多个返回值

    ```go
    func Swap(a, b int) (int, int) {
        return b, a
    }
    ```
    参数和返回值都是以传值的方式和被调用者交换数据

- 可变数量的参数

    ```go
    // more是[]int切片类型
    func sum(a int, more ...int) int {
        for _, v := range more {
            a += v
        }
        return a
    }
    ```
    可变数量的参数必须是最后出现的参数，其本质是一个切片类型的参数

- 可变参数为空接口类型

    ```go
    func Print(a ...interface{}) {
        fmt.Println(a...)
    }

    func main() {
        var a = []interface{}{123, "abc"}

        Print(a...) // 相当于Print(123, "abc")
        Print(a) // 相当于Print([]interface{}{123, "abc"})
    }
    ```

    > 123 abc <br>
    > [123 abc]

- 函数返回值可命名

    ```go
    // 通过名字修改返回值
    func Find(m map[int]int, key int) (value int, ok bool) {
        value, ok = m[key]
        return
    }
    // 通过defer语句在return语句之后修改返回值
    func Inc() (v int) {
        defer func() { v++ } ()
        return 42
    }
    ```

    > 43

    defer语句延迟执行了一个匿名函数，由于这个匿名函数捕获了外部函数的局部变量v，因此被称为闭包。闭包对捕获的外部含变量是以引用方式访问的。

    一般不在for循环语句中使用defer语句，若需要defer语句每次迭代都马上对调用参数求值，可以定义一个局部变量，或者通过函数传入该外部参数:

    ```go
    defer func(i int) {println(i)} (i)
    ```

- 函数参数传值

    只会针对数据结构中固定的部分传值，例如指针、字符串的Len、切片的Cap
    因此，被调用函数的参数为切片时，指针本身是传值的，但是指针指向的是同一份数据，则被调用函数可以通过指针修改调用参数切片中的数据。 <br>
    但是切片的Len和Cap是传值的，因此其修改无法反映到调用参数的切片中，一般需要通过返回修改猴的切片来更新之前的切片。

- 动态调整函数栈大小

    Go 1.4之后采用类似动态数组的结构来表示栈，即连续的动态栈实现。导致连续栈动态增长时，需要将之前的数据移动到新的内存空间，这会导致之前栈的全部变量地址发生改变，Go在运行时会自动更新引用了地址变化的栈变量的指针，于是指针不是固定不变的，因此不能随意将指针保存到数值变量中。

- 内存分配

    Go语言规范并没有讲到栈和堆的概念，我们无法知道函数参数或局部变量具体保存在栈或者堆中，编译器会保证指针指向的变量。

    
